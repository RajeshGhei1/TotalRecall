
import { supabase } from '@/integrations/supabase/client';
import { codeAnalysisService } from './codeAnalysisService';

export interface DocumentContent {
  title: string;
  content: string;
  lastModified: string;
  wordCount: number;
}

export interface CodeChange {
  filePath: string;
  changeType: 'created' | 'modified' | 'deleted';
  timestamp: string;
  affectedComponents?: string[];
  affectedAPIs?: string[];
}

export interface DocumentationUpdate {
  id: string;
  documentPath: string;
  updateType: 'auto' | 'manual';
  content: string;
  metadata: {
    sourceFiles: string[];
    generatedAt: string;
    version: string;
  };
}

class DocumentationService {
  private isInitialized = false;

  async initializeDocumentationSystem() {
    if (this.isInitialized) return;
    
    console.log('Initializing real-time documentation system...');
    
    // Initialize code analysis service
    await codeAnalysisService.initializeAnalysis();
    
    // Start real file watching (no longer simulated)
    codeAnalysisService.startFileWatcher();
    
    this.isInitialized = true;
    console.log('Documentation system initialized successfully with real file monitoring');
  }

  async generateDocumentationForProject(): Promise<void> {
    console.log('Generating documentation for entire project...');
    
    // Get all current documentation
    const allDocs = await codeAnalysisService.getAllDocumentation();
    console.log(`Generated documentation for ${allDocs.length} files`);
  }

  async getDocumentationContent(path: string): Promise<string | null> {
    return await codeAnalysisService.getDocumentationForPath(path);
  }

  async getAllDocumentationFiles(): Promise<any[]> {
    return await codeAnalysisService.getAllDocumentation();
  }

  // Public method to manually trigger documentation updates
  public async triggerDocumentationUpdate(filePath: string, changeType: 'created' | 'modified' | 'deleted' = 'modified') {
    await codeAnalysisService.analyzeFile(filePath);
  }

  // Public method to get recent documentation updates
  public async getRecentUpdates(limit = 10) {
    const { data, error } = await supabase
      .from('documentation_updates')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching documentation updates:', error);
      return [];
    }

    return data || [];
  }

  // Get documentation statistics
  public async getDocumentationStats() {
    const { data, error } = await supabase
      .from('documentation_updates')
      .select('update_type, created_at, metadata');

    if (error) {
      console.error('Error fetching documentation stats:', error);
      return {
        totalDocuments: 0,
        autoGenerated: 0,
        upToDate: 0,
        needsUpdate: 0
      };
    }

    const total = data?.length || 0;
    const autoGenerated = data?.filter(doc => doc.update_type === 'auto').length || 0;
    const recent = data?.filter(doc => {
      const docDate = new Date(doc.created_at);
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      return docDate > oneDayAgo;
    }).length || 0;

    return {
      totalDocuments: total,
      autoGenerated,
      upToDate: recent,
      needsUpdate: Math.max(0, total - recent)
    };
  }

  // Get file watcher status
  public getSystemStatus() {
    return {
      isInitialized: this.isInitialized,
      watcherStatus: codeAnalysisService.getWatcherStatus()
    };
  }

  // Stop the documentation system
  public stopSystem() {
    if (this.isInitialized) {
      codeAnalysisService.stopFileWatcher();
      this.isInitialized = false;
      console.log('Documentation system stopped');
    }
  }
}

export const documentationService = new DocumentationService();
